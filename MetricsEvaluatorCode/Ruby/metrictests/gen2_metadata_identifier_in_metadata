#!/home/mark_moby_wilkinson/.rvm/rubies/ruby-2.5.1/bin/ruby
require_relative 'fair_metrics_utilities'
require 'cgi'
require 'json'
require 'uri'
require 'rdf'
require 'rdf/turtle'
require 'sparql'


debug = true

def testGUID
	
	guid = @swagger.testedURI

	inchi = Regexp.new(/^\w{14}\-\w{10}\-\w$/)
	doi = Regexp.new(/^10.\d{4,9}\/[-._;()\/:A-Z0-9]+$/i)
	handle = Regexp.new(/^[2-9]0.\d{4,9}\/[-._;()\/:A-Z0-9]+$/i)
	uri = Regexp.new(/^\w+:\/?\/?[^\s]+$/)

	case 
	when guid.match(inchi)
		return do_inchi(guid)
	when guid.match(doi)
		return do_doi(guid)
	when guid.match(handle)
		return do_handle(guid)
	when guid.match(uri)
		return do_uri(guid)
	else
		@swagger.addComment("The identifier #{guid} did not match any known identification system (tested inchi, doi, handle, uri) and therefore did not pass this metric.  If you think this is an error, please contact the FAIR Metrics group (http://fairmetrics.org).")
		@swagger.score = 0
		return @swagger.createEvaluationResponse
	end
	
end

def deep_dive(parent, myHash)
	vals = []
	myHash.each {|key, value| value.is_a?(Hash) ? deep_dive(key, value) : vals << value}
	return vals
end

def do_handle(guid)
	head =  %x{curl -I -L  "http://hdl.handle.net/#{guid}"}
	$stderr.puts head
	if (head.match(/HTTP\/1\.1\s200.*?content-type:\s?(\w+\/\w+):?/im))  # handles often do a redirect, so take the header that is 200
		type = $1
		@swagger.addComment("Found a non-crossref DOI or other Handle.  ")
		@swagger.addComment("Found #{type} type of file by resolving Handle.  ")
		unless Utils::TEXT_FORMATS.include?(type)
			@swagger.addComment("  #{type} is not considered a parsable file format by this Metric Test.  If you disagree, contact us.  ")
			@swagger.score = 0
			return @swagger.createEvaluationResponse
		else
			retrieve = %x{curl -L -H "Accept: #{type}" http://hdl.handle.net/#{guid} 2>/dev/null}
			#$stderr.puts retrieve
			if retrieve.include?(guid)
				@swagger.addComment("  The GUID #{guid} was found in the content of the resolved identifier.  ")
				@swagger.score = 1
				return @swagger.createEvaluationResponse
			else
				@swagger.addComment("  The GUID #{guid} was NOT found in the content of the resolved identifier.  ")
				@swagger.score = 0
				return @swagger.createEvaluationResponse
			end
		end
		
	else
		@swagger.addComment("  Found no file type resolved by handle... this is very weird!  Probably an error.... contact us!  ")
		@swagger.addComment("Found a non-crossref DOI or other Handle")
		@swagger.score = 0
		return @swagger.createEvaluationResponse
	end
end



def do_inchi(guid)
		@swagger.addComment("Found an InChI Key GUID")
		step1 = %x{curl -H "Accept: text/turtle" https://pubchem.ncbi.nlm.nih.gov/rest/rdf/inchikey/#{guid} 2>/dev/null}
		#$stderr.puts step1
		reader = RDF::Reader.for(:turtle).new(step1) 
		g = RDF::Graph.new << reader

		query = SPARQL.parse("select ?s ?p ?o where {?s ?p ?o . FILTER(CONTAINS(str(?o), '#{guid}'))}")
		results = query.execute(g)
		#$stderr.puts results

		if results.any?
			f = results.first
			@swagger.addComment("found matching metadata #{f[:s]} #{f[:p]} #{f[:o]}")		
			@swagger.score = 1
			return @swagger.createEvaluationResponse
		else
			@swagger.addComment("SPARQL query on rdf-turtle output from pubchem failed to find the metadata identifier in the first layer of metadata.  This is not very good.  Moving down to the second layer to search further.  ")
		end
		
		query = SPARQL.parse("select ?o where {?s <http://semanticscience.org/resource/is-attribute-of> ?o}")
		results = query.execute(g)
		unless results.any
			@swagger.addComment("could not find the sio:is_attribute_of predicate in the first layer of metadata.  Aborting with failure.  ")		
			@swagger.score = 0
			return @swagger.createEvaluationResponse
		end
		
		cpd = results.first[:o]
		cpd = cpd.to_s
		cpd = cpd.gsub(/\/$/, "")
#		cpd = cpd + ".rdf"
		#https://pubchem.ncbi.nlm.nih.gov/rest/rdf/compound/CID2244/.rdf/ ->  2244.rdf
		step2 = %x{curl -L -H "Accept:text/turtle" #{cpd}  2>/dev/null}
#		$stderr.puts step2
		reader = RDF::Reader.for(:turtle).new(step2) 
		g2 = RDF::Graph.new << reader
		query = SPARQL.parse("select ?s ?p ?o where {?s ?p '#{guid}'}")
		results = query.execute(g2)
		unless results.any?
			@swagger.score = 0
			@swagger.addComment("Failed to find #{guid} in RDF Turtle output of #{cpd}.  Aborting with failure.  ")
			return @swagger.createEvaluationResponse
		end
		f = results.first
		@swagger.addComment("found matching metadata #{f[:s]} #{f[:p]} #{f[:o]}.  Success!")		
		@swagger.score = 1
		return @swagger.createEvaluationResponse
end

def do_doi(guid)
		@swagger.addComment("Found a Crossref DOI - testing its metadata.  ")
		rdf = %x{curl -s -L -H   "Accept: text/turtle" "http://doi.org/#{guid}" 2>/dev/null}
		reader = RDF::Reader.for(:turtle).new(rdf) 
		g = RDF::Graph.new << reader

		query = SPARQL.parse("select ?s ?p ?o where {?s ?p '#{guid}'}")
		results = query.execute(g)
		if results.any?
			@swagger.score = 1
			@swagger.addComment("Found precise match of #{guid} in output parsed from crossref metadata")
			return @swagger.createEvaluationResponse
		end


		query = SPARQL.parse("select ?s ?p ?o where {?s ?p ?o . FILTER(REGEX(str(?o), '#{guid}'))}")
		results = query.execute(g)
		if results.any?
			@swagger.score = 0.75
			@swagger.addComment("Found pattern (regexp) match of #{guid} in output parsed from crossref metadata")
			return @swagger.createEvaluationResponse
		end

		query = SPARQL.parse("select ?s ?p ?o where {?s ?p ?o . FILTER(REGEX(str(?s), '#{guid}'))}")
		results = query.execute(g)
		if results.any?
			@swagger.score = 0.75
			@swagger.addComment("Found pattern (regexp) match of #{guid} in output parsed from crossref metadata")
			return @swagger.createEvaluationResponse
		end
			
		@swagger.score = 0
		@swagger.addComment("Failed to find precise or even pattern-match of #{guid} in output parsed from crossref metadata")
		return @swagger.createEvaluationResponse
end

def do_uri(guid)
		@swagger.addComment("Found a URI.  ")
		result = %x{extruct #{guid} 2>&1}
		hash = JSON.parse(result)

		vals = deep_dive(nil, hash)
		if vals.contain?guid
			@swagger.addComment "found #{guid} in metadata"
			@swagger.score = 1
		else
			@swagger.addComment "DID NOT find #{guid} in metadata"
			@swagger.score = 0
		end
			
		return @swagger.createEvaluationResponse
end









# =======================================================================


if debug
#	@input = '{"subject": "10.5281/zenodo.1147435"}'  # doi
#	@input = '{"subject": "BSYNRYMUTXBXSQ-UHFFFAOYSA-N"}' # inchi
#	@input = '{"subject": "LFQSCWFLJHTTHZ-UHFFFAOYSA-N"}' # another inchi
	@input = '{"subject": "20.1000/105"}'  # handle
else 
	@input = $stdin.read
end

cgi = CGI.new

schemas = {'subject' => ['string', "the GUID being tested"]}

@swagger = Swagger.new({
			:title => "FAIR Metrics Gen2- Metadata Identifier Explicitly In Metadata",
			:description => "Metric to test if the metadata contains the unique identifier to the metadata itself.  This is done using a variety of 'scraping' tools, including DOI metadata resolution, the use of the 'extruct' Python tool, and others...",
			:tests_metric => 'https://purl.org/fair-metrics/FM_F3',
			:applies_to_principle => "F3",
			:organization => 'FAIR Metrics Authoring Group',
			:org_url => 'http://fairmetrics.org',
			:responsible_developer => "Mark D Wilkinson",
			:email => 'markw@illuminae.com',
			:developer_ORCiD => '0000-0001-6960-357X',
			:protocol => 'http',
			:host => 'linkeddata.systems',
			:basePath => '/cgi-bin',
			:path => '/FAIR_Tests/gen2_metadata_identifier_in_metadata',
			:response_description => 'The response is a value between 0 and 1, depending on the precision of the match found (regexp match scores slightly lower)',
			:schemas => schemas,
			:fairsharing_key_location => '../fairsharing.key',
				 				 
})

if (!cgi.request_method or cgi.request_method == "GET") and !debug
        puts "Content-type: application/openapi+yaml;version=3.0\n\n"
        puts @swagger.getSwagger
elsif cgi.request_method == "POST" or debug
        input_json = JSON.parse(@input)
        guid = input_json["subject"]
        @swagger.testedURI = guid
        response = testGUID
        puts "Content-type: application/json+ld\n\n"
        puts response
end
